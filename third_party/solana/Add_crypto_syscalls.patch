Index: account-decoder/src/parse_token.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- account-decoder/src/parse_token.rs	(revision 998f9725d06052be4f70293ab53041d660646987)
+++ account-decoder/src/parse_token.rs	(revision c7427aae23633651466a068035b9cc1b2033a42b)
@@ -30,11 +30,7 @@
     if data.len() == Account::get_packed_len() {
         let account = Account::unpack(data)
             .map_err(|_| ParseAccountError::AccountNotParsable(ParsableAccount::SplToken))?;
-        let decimals = mint_decimals.ok_or_else(|| {
-            ParseAccountError::AdditionalDataMissing(
-                "no mint_decimals provided to parse spl-token account".to_string(),
-            )
-        })?;
+        let decimals = mint_decimals.or(Some(0))?;
         Ok(TokenAccountType::Account(UiTokenAccount {
             mint: account.mint.to_string(),
             owner: account.owner.to_string(),
Index: fetch-spl.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- fetch-spl.sh	(revision 998f9725d06052be4f70293ab53041d660646987)
+++ fetch-spl.sh	(revision c7427aae23633651466a068035b9cc1b2033a42b)
@@ -40,6 +40,9 @@
 fetch_program token 2.0.3 TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA BPFLoader1111111111111111111111111111111111
 fetch_program memo  1.0.0 Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo BPFLoader1111111111111111111111111111111111

+# Add bridge
+genesis_args+=(--bpf-program Bridge1p5gheXUvJ6jGWGeCsgPKgnE3YgdGKRVCMY9o BPFLoader2111111111111111111111111111111111 /opt/solana/deps/spl_bridge.so)
+
 echo "${genesis_args[@]}" > spl-genesis-args.sh

 echo
Index: Cargo.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Cargo.lock	(revision c7427aae23633651466a068035b9cc1b2033a42b)
+++ Cargo.lock	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -274,12 +274,22 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b"
 dependencies = [
- "block-padding",
+ "block-padding 0.1.5",
  "byte-tools",
  "byteorder",
  "generic-array 0.12.3",
 ]

+[[package]]
+name = "block-buffer"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4"
+dependencies = [
+ "block-padding 0.2.1",
+ "generic-array 0.14.3",
+]
+
 [[package]]
 name = "block-padding"
 version = "0.1.5"
@@ -289,6 +299,12 @@
  "byte-tools",
 ]

+[[package]]
+name = "block-padding"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8d696c370c750c948ada61c69a0ee2cbbb9c50b1019ddb86d9317157a99c2cae"
+
 [[package]]
 name = "bs58"
 version = "0.3.1"
@@ -615,6 +631,12 @@
  "lazy_static",
 ]

+[[package]]
+name = "crunchy"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"
+
 [[package]]
 name = "crypto-mac"
 version = "0.7.0"
@@ -664,7 +686,7 @@
 checksum = "5d85653f070353a16313d0046f173f70d1aadd5b42600a14de626f0dfb3473a5"
 dependencies = [
  "byteorder",
- "digest",
+ "digest 0.8.1",
  "rand_core 0.5.1",
  "subtle 2.2.2",
  "zeroize",
@@ -707,6 +729,15 @@
  "generic-array 0.12.3",
 ]

+[[package]]
+name = "digest"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
+dependencies = [
+ "generic-array 0.14.3",
+]
+
 [[package]]
 name = "dir-diff"
 version = "0.3.2"
@@ -1289,7 +1320,18 @@
 checksum = "5dcb5e64cda4c23119ab41ba960d1e170a774c8e4b9d9e6a9bc18aabf5e59695"
 dependencies = [
  "crypto-mac",
- "digest",
+ "digest 0.8.1",
+]
+
+[[package]]
+name = "hmac-drbg"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c6e570451493f10f6581b48cdd530413b63ea9e780f544bfd3bdcaa0d89d1a7b"
+dependencies = [
+ "digest 0.8.1",
+ "generic-array 0.12.3",
+ "hmac",
 ]

 [[package]]
@@ -1723,6 +1765,12 @@
  "ws",
 ]

+[[package]]
+name = "keccak"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67c21572b4949434e4fc1e1978b99c5f77064153c59d998bf13ecd96fb5ecba7"
+
 [[package]]
 name = "kernel32-sys"
 version = "0.2.2"
@@ -1791,6 +1839,22 @@
  "libc",
 ]

+[[package]]
+name = "libsecp256k1"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fc1e2c808481a63dc6da2074752fdd4336a3c8fcc68b83db6f1fd5224ae7962"
+dependencies = [
+ "arrayref",
+ "crunchy",
+ "digest 0.8.1",
+ "hmac-drbg",
+ "rand 0.7.3",
+ "sha2",
+ "subtle 2.2.2",
+ "typenum",
+]
+
 [[package]]
 name = "linked-hash-map"
 version = "0.5.3"
@@ -2141,6 +2205,12 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c"

+[[package]]
+name = "opaque-debug"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5"
+
 [[package]]
 name = "openssl"
 version = "0.10.29"
@@ -3093,10 +3163,10 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df"
 dependencies = [
- "block-buffer",
- "digest",
+ "block-buffer 0.7.3",
+ "digest 0.8.1",
  "fake-simd",
- "opaque-debug",
+ "opaque-debug 0.2.3",
 ]

 [[package]]
@@ -3111,10 +3181,22 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a256f46ea78a0c0d9ff00077504903ac881a1dafdc20da66545699e7776b3e69"
 dependencies = [
- "block-buffer",
- "digest",
+ "block-buffer 0.7.3",
+ "digest 0.8.1",
  "fake-simd",
- "opaque-debug",
+ "opaque-debug 0.2.3",
+]
+
+[[package]]
+name = "sha3"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f81199417d4e5de3f04b1e871023acea7389672c4135918f05aa9cbf2f2fa809"
+dependencies = [
+ "block-buffer 0.9.0",
+ "digest 0.9.0",
+ "keccak",
+ "opaque-debug 0.3.0",
 ]

 [[package]]
@@ -4310,6 +4392,21 @@
  "syn 1.0.27",
 ]

+[[package]]
+name = "solana-secp256k1"
+version = "1.4.0"
+dependencies = [
+ "bincode",
+ "digest 0.9.0",
+ "libsecp256k1",
+ "log 0.3.9",
+ "rand 0.7.3",
+ "sha3",
+ "solana-logger 1.4.0",
+ "solana-runtime",
+ "solana-sdk 1.4.0",
+]
+
 [[package]]
 name = "solana-stake-accounts"
 version = "1.4.0"
Index: Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Cargo.toml	(revision c7427aae23633651466a068035b9cc1b2033a42b)
+++ Cargo.toml	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -36,6 +36,7 @@
     "net-shaper",
     "notifier",
     "poh-bench",
+    "programs/secp256k1",
     "programs/bpf_loader",
     "programs/budget",
     "programs/config",
Index: programs/secp256k1/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/secp256k1/Cargo.toml	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/secp256k1/Cargo.toml	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -0,0 +1,32 @@
+[package]
+name = "solana-secp256k1"
+description = "Blockchain, Rebuilt for Scale"
+version = "1.4.0"
+documentation = "https://docs.rs/solana"
+homepage = "https://solana.com/"
+readme = "README.md"
+repository = "https://github.com/solana-labs/solana"
+authors = ["Solana Maintainers <maintainers@solana.foundation>"]
+license = "Apache-2.0"
+edition = "2018"
+publish = false
+
+[dependencies]
+bincode = "1.1.4"
+solana-logger = { path = "../../logger", version = "1.4.0" }
+solana-sdk = { path = "../../sdk", version = "1.4.0" }
+libsecp256k1 = "0.3.5"
+sha3 = "0.9.1"
+digest = "0.9.0"
+log = ""
+rand = "0.7.0"
+
+[dev-dependencies]
+solana-runtime = { path = "../../runtime", version = "1.4.0" }
+
+[lib]
+crate-type = ["lib"]
+name = "solana_secp256k1_program"
+
+[package.metadata.docs.rs]
+targets = ["x86_64-unknown-linux-gnu"]
Index: programs/secp256k1/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/secp256k1/src/lib.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/secp256k1/src/lib.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -0,0 +1,2 @@
+extern crate secp256k1;
+mod secp256k1_instruction;
Index: programs/secp256k1/src/secp256k1_instruction.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/secp256k1/src/secp256k1_instruction.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/secp256k1/src/secp256k1_instruction.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -0,0 +1,158 @@
+use digest::Digest;
+use solana_sdk::pubkey::Pubkey;
+use solana_sdk::{account::KeyedAccount, instruction::InstructionError};
+
+enum Secp256k1Error {
+    InvalidSignature,
+    InvalidRecoveryId,
+}
+
+const HASHED_PUBKEY_SERIALIZED_SIZE: usize = 20;
+const SIGNATURE_SERIALIZED_SIZE: usize = 64;
+
+fn construct_eth_pubkey(pubkey: &secp256k1::PublicKey) -> [u8; HASHED_PUBKEY_SERIALIZED_SIZE] {
+    let mut addr = [0u8; HASHED_PUBKEY_SERIALIZED_SIZE];
+    addr.copy_from_slice(&sha3::Keccak256::digest(&pubkey.serialize()[1..])[12..]);
+    addr
+}
+
+pub fn process_instruction(
+    _program_id: &Pubkey,
+    _keyed_accounts: &[KeyedAccount],
+    data: &[u8],
+) -> Result<(), InstructionError> {
+    if data.len() < (HASHED_PUBKEY_SERIALIZED_SIZE + SIGNATURE_SERIALIZED_SIZE + 1) {
+        return Err(InstructionError::InvalidInstructionData);
+    }
+    let signature = secp256k1::Signature::parse_slice(
+        &data[HASHED_PUBKEY_SERIALIZED_SIZE
+            ..HASHED_PUBKEY_SERIALIZED_SIZE + SIGNATURE_SERIALIZED_SIZE],
+    )
+    .map_err(|_| InstructionError::Custom(Secp256k1Error::InvalidSignature as u32))?;
+
+    let recovery_id = secp256k1::RecoveryId::parse(
+        data[HASHED_PUBKEY_SERIALIZED_SIZE + SIGNATURE_SERIALIZED_SIZE],
+    )
+    .map_err(|_| InstructionError::Custom(Secp256k1Error::InvalidRecoveryId as u32))?;
+
+    let mut hasher = sha3::Keccak256::new();
+    hasher.update(&data[HASHED_PUBKEY_SERIALIZED_SIZE + SIGNATURE_SERIALIZED_SIZE + 1..]);
+    let message_hash = hasher.finalize();
+
+    let pubkey = secp256k1::recover(
+        &secp256k1::Message::parse_slice(&message_hash).unwrap(),
+        &signature,
+        &recovery_id,
+    )
+    .map_err(|_| InstructionError::Custom(Secp256k1Error::InvalidSignature as u32))?;
+    let eth_pubkey = construct_eth_pubkey(&pubkey);
+
+    if data[..HASHED_PUBKEY_SERIALIZED_SIZE] == eth_pubkey {
+        Ok(())
+    } else {
+        Err(InstructionError::Custom(
+            Secp256k1Error::InvalidSignature as u32,
+        ))
+    }
+}
+
+solana_sdk::declare_program!(
+    solana_sdk::secp256k1_program::ID,
+    solana_keccak_secp256k1_program,
+    process_instruction
+);
+
+#[cfg(test)]
+pub mod test {
+    use super::construct_eth_pubkey;
+    use crate::secp256k1_instruction::SIGNATURE_SERIALIZED_SIZE;
+    use digest::Digest;
+    use log::*;
+    use rand::{thread_rng, Rng};
+    use solana_runtime::bank::Bank;
+    use solana_sdk::instruction::Instruction;
+    use solana_sdk::transaction::Transaction;
+    use solana_sdk::{genesis_config::create_genesis_config, signature::Signer};
+
+    fn new_secp256k1_instruction(
+        priv_key: &secp256k1::SecretKey,
+        message_arr: &[u8],
+    ) -> Instruction {
+        let secp_pubkey = secp256k1::PublicKey::from_secret_key(priv_key);
+        let eth_pubkey = construct_eth_pubkey(&secp_pubkey);
+        let mut hasher = sha3::Keccak256::new();
+        hasher.update(&message_arr);
+        let message_hash = hasher.finalize();
+        let mut message_hash_arr = [0u8; 32];
+        message_hash_arr.copy_from_slice(&message_hash.as_slice());
+        let message = secp256k1::Message::parse(&message_hash_arr);
+        let (signature, recovery_id) = secp256k1::sign(&message, priv_key);
+        let signature_arr = signature.serialize();
+        assert_eq!(signature_arr.len(), SIGNATURE_SERIALIZED_SIZE);
+
+        let mut instruction_data = vec![];
+        instruction_data.resize(
+            eth_pubkey.len() + signature_arr.len() + message_arr.len() + 1,
+            0,
+        );
+        instruction_data[..eth_pubkey.len()].copy_from_slice(&eth_pubkey);
+        instruction_data[eth_pubkey.len()..eth_pubkey.len() + signature_arr.len()]
+            .copy_from_slice(&signature_arr);
+        instruction_data[eth_pubkey.len() + signature_arr.len()] = recovery_id.serialize();
+        instruction_data[eth_pubkey.len() + signature_arr.len() + 1..].copy_from_slice(message_arr);
+
+        Instruction {
+            program_id: crate::secp256k1_instruction::id(),
+            accounts: vec![],
+            data: instruction_data,
+        }
+    }
+
+    #[test]
+    fn test_secp256k1() {
+        use super::Secp256k1Error;
+        use solana_sdk::instruction::InstructionError;
+        use solana_sdk::transaction::TransactionError;
+        solana_logger::setup();
+
+        let (genesis_config, mint_keypair) = create_genesis_config(1_000_000_000);
+        let mut bank = Bank::new(&genesis_config);
+
+        let secp_privkey = secp256k1::SecretKey::random(&mut thread_rng());
+        let message_arr = b"hello";
+        let mut secp_instruction = new_secp256k1_instruction(&secp_privkey, message_arr);
+
+        let tx = Transaction::new_signed_with_payer(
+            &[secp_instruction.clone()],
+            Some(&mint_keypair.pubkey()),
+            &[&mint_keypair],
+            bank.last_blockhash(),
+        );
+        bank.add_builtin_program(
+            "secp256k1",
+            crate::secp256k1_instruction::id(),
+            crate::secp256k1_instruction::process_instruction,
+        );
+
+        info!("tx: {:?}", tx);
+        assert!(bank.process_transaction(&tx).is_ok());
+
+        let index = thread_rng().gen_range(0, secp_instruction.data.len());
+        secp_instruction.data[index] = secp_instruction.data[index].wrapping_add(12);
+        let tx = Transaction::new_signed_with_payer(
+            &[secp_instruction],
+            Some(&mint_keypair.pubkey()),
+            &[&mint_keypair],
+            bank.last_blockhash(),
+        );
+        match bank.process_transaction(&tx) {
+            Ok(_) => panic!("should error"),
+            Err(e) => match e {
+                TransactionError::InstructionError(0, InstructionError::Custom(code)) => {
+                    assert_eq!(code, Secp256k1Error::InvalidSignature as u32);
+                }
+                _ => panic!("should error"),
+            },
+        }
+    }
+}
Index: sdk/src/fee_calculator.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/fee_calculator.rs	(revision c7427aae23633651466a068035b9cc1b2033a42b)
+++ sdk/src/fee_calculator.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -1,5 +1,6 @@
 use crate::clock::{DEFAULT_TICKS_PER_SECOND, DEFAULT_TICKS_PER_SLOT};
 use crate::message::Message;
+use crate::secp256k1_program;
 use log::*;

 #[derive(Serialize, Deserialize, PartialEq, Eq, Clone, Debug, AbiExample)]
@@ -26,7 +27,18 @@
     }

     pub fn calculate_fee(&self, message: &Message) -> u64 {
-        self.lamports_per_signature * u64::from(message.header.num_required_signatures)
+        let mut num_secp_signatures: u64 = 0;
+        for instruction in &message.instructions {
+            let program_index = instruction.program_id_index as usize;
+            if program_index < message.account_keys.len() {
+                let id = message.account_keys[program_index];
+                if secp256k1_program::check_id(&id) {
+                    num_secp_signatures += 1;
+                }
+            }
+        }
+        self.lamports_per_signature
+            * (u64::from(message.header.num_required_signatures) + num_secp_signatures)
     }
 }

@@ -203,6 +215,27 @@
         assert_eq!(FeeCalculator::new(2).calculate_fee(&message), 4);
     }

+    #[test]
+    fn test_fee_calculator_calculate_fee_secp256k1() {
+        use crate::instruction::Instruction;
+        let pubkey0 = Pubkey::new(&[0; 32]);
+        let pubkey1 = Pubkey::new(&[1; 32]);
+        let ix0 = system_instruction::transfer(&pubkey0, &pubkey1, 1);
+        let secp_instruction = Instruction {
+            program_id: crate::secp256k1_program::id(),
+            accounts: vec![],
+            data: vec![],
+        };
+        let secp_instruction2 = Instruction {
+            program_id: crate::secp256k1_program::id(),
+            accounts: vec![],
+            data: vec![1],
+        };
+
+        let message = Message::new(&[ix0, secp_instruction, secp_instruction2], Some(&pubkey0));
+        assert_eq!(FeeCalculator::new(1).calculate_fee(&message), 3);
+    }
+
     #[test]
     fn test_fee_rate_governor_derived_default() {
         solana_logger::setup();
Index: sdk/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/lib.rs	(revision c7427aae23633651466a068035b9cc1b2033a42b)
+++ sdk/src/lib.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -37,6 +37,7 @@
 pub mod rent;
 pub mod rpc_port;
 pub mod sanitize;
+pub mod secp256k1_program;
 pub mod short_vec;
 pub mod slot_hashes;
 pub mod slot_history;
Index: sdk/src/secp256k1_program.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/secp256k1_program.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ sdk/src/secp256k1_program.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
@@ -0,0 +1,1 @@
+solana_sdk::declare_id!("KeccakSecp256k11111111111111111111111111111");
Index: programs/bpf/Cargo.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/Cargo.lock	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/bpf/Cargo.lock	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -1693,6 +1693,14 @@
  "solana-sdk",
 ]

+[[package]]
+name = "solana-bpf-rust-instruction-introspection"
+version = "1.4.0"
+dependencies = [
+ "bincode",
+ "solana-sdk",
+]
+
 [[package]]
 name = "solana-bpf-rust-invoke"
 version = "1.4.0"
Index: programs/bpf/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/Cargo.toml	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/bpf/Cargo.toml	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -40,6 +40,7 @@
     "rust/dup_accounts",
     "rust/error_handling",
     "rust/external_spend",
+    "rust/instruction_introspection",
     "rust/invoke",
     "rust/invoked",
     "rust/iter",
Index: programs/bpf/build.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/build.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/bpf/build.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -71,6 +71,7 @@
             "dup_accounts",
             "error_handling",
             "external_spend",
+            "instruction_introspection",
             "invoke",
             "invoked",
             "iter",
Index: programs/bpf/rust/instruction_introspection/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/rust/instruction_introspection/Cargo.toml	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
+++ programs/bpf/rust/instruction_introspection/Cargo.toml	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -0,0 +1,27 @@
+
+# Note: This crate must be built using do.sh
+
+[package]
+name = "solana-bpf-rust-instruction-introspection"
+version = "1.4.0"
+description = "Solana BPF test program written in Rust"
+authors = ["Solana Maintainers <maintainers@solana.foundation>"]
+repository = "https://github.com/solana-labs/solana"
+license = "Apache-2.0"
+homepage = "https://solana.com/"
+edition = "2018"
+
+[dependencies]
+solana-sdk = { path = "../../../../sdk/", version = "1.4.0", default-features = false }
+bincode = "1.3.1"
+
+[features]
+program = ["solana-sdk/program"]
+default = ["program", "solana-sdk/default"]
+
+[lib]
+name = "solana_bpf_rust_instruction_introspection"
+crate-type = ["cdylib"]
+
+[package.metadata.docs.rs]
+targets = ["x86_64-unknown-linux-gnu"]
Index: programs/bpf/rust/instruction_introspection/Xargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/rust/instruction_introspection/Xargo.toml	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
+++ programs/bpf/rust/instruction_introspection/Xargo.toml	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -0,0 +1,2 @@
+[target.bpfel-unknown-unknown.dependencies.std]
+features = []
\ No newline at end of file
Index: programs/bpf/rust/instruction_introspection/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/rust/instruction_introspection/src/lib.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
+++ programs/bpf/rust/instruction_introspection/src/lib.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -0,0 +1,44 @@
+//! @brief Example Rust-based BPF program that exercises instruction introspection
+
+extern crate solana_sdk;
+use solana_sdk::sysvar::instructions::Instructions;
+use solana_sdk::sysvar::Sysvar;
+use solana_sdk::{
+    account_info::next_account_info, account_info::AccountInfo, entrypoint,
+    entrypoint::ProgramResult, info, instruction::Instruction, program_error::ProgramError,
+    pubkey::Pubkey,
+};
+
+entrypoint!(process_instruction);
+fn process_instruction(
+    _program_id: &Pubkey,
+    accounts: &[AccountInfo],
+    instruction_data: &[u8],
+) -> ProgramResult {
+    if instruction_data.is_empty() {
+        return Err(ProgramError::InvalidAccountData);
+    }
+
+    let secp_instruction_index = instruction_data[0];
+    let account_info_iter = &mut accounts.iter();
+    let instruction_accounts = next_account_info(account_info_iter)?;
+    assert_eq!(
+        *instruction_accounts.key,
+        solana_sdk::sysvar::instructions::id()
+    );
+    let instructions: Vec<Instruction> = Instructions::from_account_info(instruction_accounts)
+        .map_err(|_| ProgramError::InvalidAccountData)?;
+    if secp_instruction_index as usize > instructions.len() {
+        return Err(ProgramError::InvalidAccountData);
+    }
+    info!(&format!(
+        "{}",
+        instructions[secp_instruction_index as usize].program_id
+    ));
+
+    info!(&format!(
+        "{}",
+        instructions[secp_instruction_index as usize].data[0]
+    ));
+    Ok(())
+}
Index: programs/bpf/tests/programs.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf/tests/programs.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ programs/bpf/tests/programs.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -457,3 +457,38 @@
         }
     }
 }
+
+#[test]
+#[cfg(any(feature = "bpf_rust"))]
+fn test_program_bpf_instruction_introspection() {
+    solana_logger::setup();
+
+    let GenesisConfigInfo {
+        genesis_config,
+        mint_keypair,
+        ..
+    } = create_genesis_config(50_000);
+    let mut bank = Bank::new(&genesis_config);
+
+    let (name, id, entrypoint) = solana_bpf_loader_program!();
+    bank.add_builtin_loader(&name, id, entrypoint);
+    let bank = Arc::new(bank);
+    let bank_client = BankClient::new_shared(&bank);
+
+    let program_id = load_bpf_program(
+        &bank_client,
+        &mint_keypair,
+        "solana_bpf_rust_instruction_introspection",
+    );
+    let account_metas = vec![AccountMeta::new(
+        solana_sdk::sysvar::instructions::id(),
+        false,
+    )];
+    let instruction = Instruction::new(program_id, &0u8, account_metas);
+    let result = bank_client.send_and_confirm_instruction(&mint_keypair, instruction);
+    assert!(result.is_ok());
+
+    let instruction = Instruction::new(program_id, &0u8, vec![]);
+    let result = bank_client.send_and_confirm_instruction(&mint_keypair, instruction);
+    assert!(result.is_err());
+}
Index: runtime/src/accounts.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- runtime/src/accounts.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ runtime/src/accounts.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -108,6 +108,13 @@
         false
     }

+    fn construct_instructions_account(message: &Message) -> Account {
+        let mut account = Account::default();
+        let instructions = message.decompile_instructions();
+        account.data = bincode::serialize(&instructions).unwrap();
+        account
+    }
+
     fn load_tx_accounts(
         &self,
         storage: &AccountStorage,
@@ -136,6 +143,10 @@
                         if payer_index.is_none() {
                             payer_index = Some(i);
                         }
+
+                        if solana_sdk::sysvar::instructions::check_id(key) {
+                            return Self::construct_instructions_account(message);
+                        }
                         let (account, rent) =
                             AccountsDB::load(storage, ancestors, accounts_index, key)
                                 .map(|(mut account, _)| {
Index: sdk/src/instruction.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/instruction.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ sdk/src/instruction.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -169,7 +169,7 @@
     ComputationalBudgetExceeded,
 }

-#[derive(Debug, PartialEq, Clone)]
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
 pub struct Instruction {
     /// Pubkey of the instruction processor that executes this instruction
     pub program_id: Pubkey,
Index: sdk/src/message.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/message.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ sdk/src/message.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -322,6 +322,34 @@
         }
         (writable_keys, readonly_keys)
     }
+
+    pub fn decompile_instructions(&self) -> Vec<Instruction> {
+        self.instructions
+            .iter()
+            .map(|instruction| {
+                let accounts: Vec<_> = instruction
+                    .accounts
+                    .iter()
+                    .map(|account_index| {
+                        let account_index = *account_index as usize;
+                        let is_signer = self.is_signer(account_index);
+                        let is_writable = self.is_writable(account_index);
+                        AccountMeta {
+                            pubkey: self.account_keys[account_index],
+                            is_signer,
+                            is_writable,
+                        }
+                    })
+                    .collect();
+                let program_id = self.account_keys[instruction.program_id_index as usize];
+                Instruction {
+                    program_id,
+                    data: instruction.data.clone(),
+                    accounts,
+                }
+            })
+            .collect()
+    }
 }

 #[cfg(test)]
@@ -673,4 +701,23 @@
             (vec![&id1, &id0], vec![&id3, &id2, &program_id])
         );
     }
+
+    #[test]
+    fn test_decompile_instructions() {
+        let program_id0 = Pubkey::new_rand();
+        let program_id1 = Pubkey::new_rand();
+        let id0 = Pubkey::new_rand();
+        let id1 = Pubkey::new_rand();
+        let id2 = Pubkey::new_rand();
+        let id3 = Pubkey::new_rand();
+        let instructions = vec![
+            Instruction::new(program_id0, &0, vec![AccountMeta::new(id0, false)]),
+            Instruction::new(program_id0, &0, vec![AccountMeta::new(id1, true)]),
+            Instruction::new(program_id1, &0, vec![AccountMeta::new_readonly(id2, false)]),
+            Instruction::new(program_id1, &0, vec![AccountMeta::new_readonly(id3, true)]),
+        ];
+
+        let message = Message::new(&instructions, Some(&id1));
+        assert_eq!(message.decompile_instructions(), instructions);
+    }
 }
Index: sdk/src/sysvar/instructions.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/sysvar/instructions.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
+++ sdk/src/sysvar/instructions.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -0,0 +1,11 @@
+//! This account contains the serialized transaction instructions
+//!
+
+use crate::instruction::Instruction;
+use crate::sysvar::Sysvar;
+
+pub type Instructions = Vec<Instruction>;
+
+crate::declare_sysvar_id!("instructions1111111111111111111111111111111", Instructions);
+
+impl Sysvar for Instructions {}
Index: sdk/src/sysvar/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- sdk/src/sysvar/mod.rs	(revision 61b697eef4f25bdebeb90223de8a34affdf96d3a)
+++ sdk/src/sysvar/mod.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
@@ -11,6 +11,7 @@
 pub mod clock;
 pub mod epoch_schedule;
 pub mod fees;
+pub mod instructions;
 pub mod recent_blockhashes;
 pub mod rent;
 pub mod rewards;
@@ -28,6 +29,7 @@
         || slot_hashes::check_id(id)
         || slot_history::check_id(id)
         || stake_history::check_id(id)
+        || instructions::check_id(id)
 }

 #[macro_export]
Index: account-decoder/src/parse_token.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- account-decoder/src/parse_token.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
+++ account-decoder/src/parse_token.rs	(date 1598798938438)
@@ -30,7 +30,7 @@
     if data.len() == Account::get_packed_len() {
         let account = Account::unpack(data)
             .map_err(|_| ParseAccountError::AccountNotParsable(ParsableAccount::SplToken))?;
-        let decimals = mint_decimals.or(Some(0))?;
+        let decimals = mint_decimals.or(Some(0)).unwrap();
         Ok(TokenAccountType::Account(UiTokenAccount {
             mint: account.mint.to_string(),
             owner: account.owner.to_string(),

Index: programs/bpf_loader/src/bpf_verifier.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- programs/bpf_loader/src/bpf_verifier.rs	(revision dc94838be76e0d3ee2441c47df4bb1add701c3ee)
+++ programs/bpf_loader/src/bpf_verifier.rs	(date 1598809541828)
@@ -58,7 +58,7 @@
     if prog.len() % ebpf::INSN_SIZE != 0 {
         return Err(VerifierError::ProgramLengthNotMultiple.into());
     }
-    if prog.len() > ebpf::PROG_MAX_SIZE {
+    if prog.len() > ebpf::PROG_MAX_SIZE * 2 {
         return Err(VerifierError::ProgramTooLarge(prog.len() / ebpf::INSN_SIZE).into());
     }

